# Project Coding Guidelines

This is an example of a project-level guidelines file that teams can place in their repository root.

## General Rules
- All functions must have documentation comments
- Use meaningful variable names (no single letters except for loop counters i, j, k)
- Maximum function length: 30 lines
- Maximum function parameters: 5
- Use gofmt and golint before committing

## Naming Conventions
- Use camelCase for unexported functions and variables
- Use PascalCase for exported functions, types, and variables
- Interface names should end with "er" (e.g., Reader, Writer, Handler)
- Avoid abbreviations unless they're widely understood (HTTP, URL, JSON)

## Error Handling
- Always return errors, never panic in production code
- Wrap errors with context using fmt.Errorf("operation failed: %w", err)
- Log errors at the boundary where they're handled
- Use structured logging with consistent fields (user_id, operation, etc.)
- Define custom error types for different error categories

## Performance
- Use strings.Builder for string concatenation in loops
- Prefer sync.Pool for expensive object reuse
- Always profile before optimizing
- Use context.Context for cancellation and timeouts
- Avoid allocations in hot paths

## Security
- Validate all user inputs at API boundaries
- Use parameterized queries for database operations
- Never log sensitive information (passwords, tokens, PII)
- Implement proper authentication and authorization
- Use TLS for all network communications

## Architecture
- Follow dependency injection pattern
- Use interfaces for external dependencies
- Keep business logic separate from infrastructure concerns
- Implement proper separation of concerns
- Use clean architecture principles

## Testing
- Maintain minimum 80% test coverage
- Write table-driven tests where appropriate
- Use testify/assert for cleaner test assertions
- Mock external dependencies
- Test error conditions as well as happy paths

## Database
- Use context with timeout for all database operations
- Implement proper connection pooling
- Use transactions for operations that modify multiple tables
- Never build SQL queries with string concatenation
- Use database migrations for schema changes

## Concurrency
- Use channels for communication between goroutines
- Avoid shared mutable state
- Use sync package primitives appropriately
- Always handle goroutine lifecycle properly
- Use context for cancellation in goroutines